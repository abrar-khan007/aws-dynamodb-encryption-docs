<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "file://zonbook/docbookx.dtd"
[
  <!ENTITY % phrases-ddb-encrypt SYSTEM "shared/phrases-ddb-encrypt.ent">
  %phrases-ddb-encrypt;
   <!ENTITY % phrases-kms SYSTEM "shared/phrases-kms.ent">
    %phrases-kms;  
  <!ENTITY % xinclude SYSTEM "file://AWSShared/common/xinclude.mod">
  %xinclude;
  <!ENTITY % phrases-shared SYSTEM "file://AWSShared/common/phrases-shared.ent">
  %phrases-shared;
 ]>
<chapter id="data-model">
    <info>
        <title id="data-model.title">Changing your data model</title>
        <titleabbrev>Changing your data model</titleabbrev>
        <abstract>
            <para>Learn how to update your &DDB; attribute actions</para>
        </abstract>
    </info>
    <para>Every time you encrypt or decrypt an item, you need to provide <link
            linkend="attribute-actions">attribute actions</link> that tell the &DDBEC; which
        attributes to encrypt and sign, which attributes to sign (but not encrypt), and which to
        ignore. Attribute actions are not saved in the encrypted item and the &DDBEC; does not
        update your attribute actions automatically.</para>
    <para>Whenever you change your data model, that is, when you add or remove attributes from your
        table items, you risk an error. If the attribute actions that you specify do not account for
        all attributes in the item, the item might not be encrypted and signed the way that you
        intend. More importantly, if the attribute actions that you provide when decrypting an item
        differ from the attribute actions that you provided when encrypting the item, the signature
        verification might fail. </para>
    <para>For example, if the attribute actions used to encrypt the item tell it to sign the
            <code>test</code> attribute, the signature in the item will include the
            <code>test</code> attribute. But if the attribute actions used to decrypt the item do
        not account for the <code>test</code> attribute, the verification will fail because the
        client will try to verify a signature that does not include the <code>test</code> attribute. </para>
    <para>This is a particular problem when multiple applications read and write the same &DDB;
        items because the &DDBEC; must calculate the same signature for items in all applications.
        It's also a problem for any distributed application because changes in attribute actions
        must propagate to all hosts. Even if your &DDB; tables are accessed by one host in one
        process, establishing a best practice process will help prevent errors if the project ever
        becomes more complex.</para>
    <para>To avoid signature validation errors that prevent you from reading your table items, use
        the following guidance.</para>
    <itemizedlist>
        <listitem>
            <para><link linkend="add-attribute">Adding an attribute</link> &emdash; If the new
                attribute changes your attribute actions, fully deploy the attribute action change
                before including the new attribute in an item.</para>
        </listitem>
        <listitem>
            <para><link linkend="remove-attribute">Removing an attribute</link> &emdash; If you stop
                using an attribute in your items, do not change your attribute actions. </para>
        </listitem>
        <listitem>
            <para>Changing the action &emdash; After you have used an attribute actions
                configuration to encrypt your table items, you cannot safely change the default
                action or the action for an existing attribute without re-encrypting every item in
                your table.</para>
        </listitem>
    </itemizedlist>
    <para>Signature validation errors can be extremely difficult to resolve, so the best approach is
        to prevent them. </para>
    <para role="topiclist"><!-- TOPICLIST --></para>

    <section id="add-attribute">
        <info>
            <title id="add-attribute.title">Adding an attribute</title>
        </info>
        <para>When you add a new attribute to table items, you might need to change your attribute
            actions. To prevent signature validation errors, we recommend that you implement this
            change in a two-stage process. Verify that the first stage is complete before starting
            the second stage.</para>
        <orderedlist>
            <listitem>
                <para>Change the attribute actions in all applications that read or write to the
                    table. Deploy these changes and confirm that the update has been propagated to
                    all destination hosts. </para>
            </listitem>
            <listitem>
                <para>Write values to the new attribute in your table items.</para>
            </listitem>
        </orderedlist>
        <para>This two-stage approach ensures that all applications and hosts have the same
            attribute actions, and will calculate the same signature, before any encounter the new
            attribute. This is important even when the action for the attribute is <emphasis
                role="italic">Do nothing</emphasis> (don't encrypt or sign), because the default for
            some encryptors is to encrypt and sign.</para>
        <para>The following examples show the code for the first stage in this process. They add a
            new item attribute, <code>link</code>, which stores a link to another table item.
            Because this link must remain in plain text, the example assigns it the sign-only
            action. After fully deploying this change and then verifying that all applications and
            hosts have the new attribute actions, you can begin to use the <code>link</code>
            attribute in your table items.</para>
        <tablist>
            <tablistentry>
                <tabname>Java &DDB; Mapper</tabname>
                <tabcontent>
                    <para>When using the <code>&DDB; Mapper</code> and
                            <code>AttributeEncryptor</code>, by default, all attributes are
                        encrypted and signed except for primary keys, which are signed but not
                        encrypted. To specify a sign-only action, use the <code>@DoNotEncrypt</code>
                        annotation. </para>
                    <para>This example uses the <code>@DoNotEncrypt</code> annotation for the new
                            <code>link</code> attribute.</para>
                    <programlisting language="java">@DynamoDBTable(tableName = "ExampleTable")
public static final class DataPoJo {
  private String partitionAttribute;
  private int sortAttribute;
  <emphasis role="bold">private String link;</emphasis>

  @DynamoDBHashKey(attributeName = "partition_attribute")
  public String getPartitionAttribute() {
    return partitionAttribute;
  }
    
  public void setPartitionAttribute(String partitionAttribute) {
    this.partitionAttribute = partitionAttribute;
  }

  @DynamoDBRangeKey(attributeName = "sort_attribute")
  public int getSortAttribute() {
    return sortAttribute;
  }

  public void setSortAttribute(int sortAttribute) {
    this.sortAttribute = sortAttribute;
  }

  <emphasis role="bold">@DynamoDBAttribute(attributeName = "link")
  @DoNotEncrypt
  public String getLink() {
    return link;
  }

  public void setLink(String link) {
    this.link = link;
  }</emphasis>

  @Override
  public String toString() {
    return "DataPoJo [partitionAttribute=" + partitionAttribute + ",
        sortAttribute=" + sortAttribute + ",
        <emphasis role="bold">link=" + link + "</emphasis>]";
  }
}            </programlisting>
                </tabcontent>
            </tablistentry>
            <tablistentry>
                <tabname>Java &DDB; encryptor</tabname>
                <tabcontent><para> In the lower-level &DDB; encryptor, you must set actions for each attribute. This example
                        uses a switch statement where the default is <code>encryptAndSign</code> and
                        exceptions are specified for the partition key, sort key, and the new
                            <code>link</code> attribute. In this example, if the link attribute code
                        was not fully deployed before it was used, the link attribute would be
                        encrypted and signed by some applications, but only signed by others.</para>
                <programlisting language="java">for (final String attributeName : record.keySet()) {
    switch (attributeName) {
        case partitionKeyName:
            // fall through to the next case
        case sortKeyName:
            // partition and sort keys must be signed, but not encrypted
            actions.put(attributeName, signOnly);
            break;
        <emphasis role="bold">case "link":
            // only signed
            actions.put(attributeName, signOnly);
            break;</emphasis>
        default:
            // Encrypt and sign all other attributes
            actions.put(attributeName, encryptAndSign);
            break;
    }
}               </programlisting></tabcontent>
            </tablistentry>
            <tablistentry>
                <tabname>Python</tabname>
                <tabcontent>
                    <para>In the &DDBEC; for Python, you can specify a default action for all
                        attributes and then specify exceptions. </para>
                    <para>If you use a Python <link linkend="python-helpers">client helper
                            class</link>, you don't need to specify an attribute action for the
                        primary key attributes. The client helper classes prevent you from
                        encrypting your primary key. However, if you are not using a client helper
                        class, you must set the SIGN_ONLY action on your partition key and sort key.
                        If you accidentally encrypt your partition or sort key, you won't be able to
                        recover your data without a full table scan.</para>
                    <para>This example specifies an exception for the new <code>link</code>
                        attribute, which gets the <code>SIGN_ONLY</code> action.</para>
                    <programlisting language="py">actions = AttributeActions(
    default_action=CryptoAction.ENCRYPT_AND_SIGN,
    attribute_actions={
      'example': CryptoAction.DO_NOTHING,  
      <emphasis role="bold">'link': CryptoAction.SIGN_ONLY</emphasis>
    }
)</programlisting>
                </tabcontent>
            </tablistentry>
        </tablist>




    </section>
    <section id="remove-attribute">
        <info>
            <title id="remove-attribute.title">Removing an attribute</title>
        </info>
        <para>If you no longer need an attribute in items that have been encrypted with the &DDBEC;,
            you can stop using the attribute. However, do not delete or change the action for that
            attribute. If you do, and then encounter an item with that attribute, the signature
            calculated for the item will not match the original signature, and the signature
            validation will fail.</para>
        <para>Although you might be tempted to remove all traces of the attribute from your code,
            add a comment that the item is no longer used instead of deleting it. Even if you do a
            full table scan to delete all instances of the attribute, an encrypted item with that
            attribute might be cached or in process somewhere in your configuration.</para>
    </section>

</chapter>
