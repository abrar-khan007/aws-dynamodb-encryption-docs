<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "file://zonbook/docbookx.dtd"
[
  <!ENTITY % phrases-ddb-encrypt SYSTEM "shared/phrases-ddb-encrypt.ent">
  %phrases-ddb-encrypt;
  <!ENTITY % phrases-kms SYSTEM "shared/phrases-kms.ent">
  %phrases-kms;
  <!ENTITY % xinclude SYSTEM "file://AWSShared/common/xinclude.mod">
  %xinclude;
  <!ENTITY % phrases-shared SYSTEM "file://AWSShared/common/phrases-shared.ent">
  %phrases-shared;
 ]>
<section id="most-recent-provider" role="topic">
  <info>
    <title id="most-recent-provider.title">&MRP;</title>
    <abstract>
      <para>Learn about the &MRP; cryptographic materials provider in the &DDBEC; and
        how to use it in your &DDB; applications.</para>
    </abstract>
  </info>
  <para>The <emphasis role="italic">&MRP;</emphasis> is a <link
    linkend="concept-material-provider">cryptographic materials provider</link> (CMP) that is
    designed to work with a <link linkend="provider-store">provider store</link>. It gets CMPs from
    the provider store, and gets the cryptographic materials that it returns from the CMPs. It
    typically uses each CMP to satisfy multiple requests for cryptographic materials. But you can
    use the features of its provider store to control the extent to which materials are reused,
    determine how often its CMP is rotated, and even change the type of CMP that it uses without
    changing the &MRP;.</para>
  <note>
    <para>The code associated with the <code>MostRecentProvider</code> symbol for the &MRP; might
      store cryptographic materials in memory for the lifetime of the process. It might allow a
      caller to use keys that they're no longer authorized to use. </para>
    <para>The <code>MostRecentProvider</code> symbol is deprecated in older supported versions of
      the &DDBEC; and removed from version &mrp-update-version;. It is replaced by the
        <code>CachingMostRecentProvider</code> symbol. For details, see <xref linkend="mrp-versions"
        endterm="mrp-versions.title"/>.</para>
  </note>
  <para>The &MRP; is a good choice for applications that need to minimize calls to
    the provider store and its cryptographic source, and applications that can reuse some
    cryptographic materials without violating their security requirements. For example, It allows
    you to protect your cryptographic materials under an <ulink url="&url-kms-dev;"
    >&KMSlong;</ulink> (&KMS;) <ulink url="&url-kms-dev;concepts.html#master_keys">&CMKlong;</ulink> without calling &KMS; every time you encrypt or decrypt an item.</para>
  <para>The provider store that you choose determines the type of CMPs that the &MRP; uses and how
    often it gets a new CMP. You can use any compatible provider store with the &MRP;, including
    custom provider stores that you design. </para>
  <para>The &DDBEC; includes a <emphasis role="italic">MetaStore</emphasis> that creates and returns
    <link linkend="wrapped-provider">Wrapped Materials Providers</link> (Wrapped CMPs). The
    MetaStore saves multiple versions of the Wrapped CMPs that it generates in an internal &DDB;
    table and protects them with client-side encryption by an internal instance of the &DDBEC;. </para>
  <para>You can configure the MetaStore to use any type of internal CMP to protect the materials in
    the table, including a <link linkend="direct-kms-provider">&direct-kms;</link> that
    generates cryptographic materials protected by your &KMS; &CMKlong;, a Wrapped CMP
    that uses wrapping and signing keys that you supply, or a compatible custom CMP that you
    design.</para>
  <para><emphasis role="bold">For example code, see:</emphasis></para>
  <itemizedlist>
    <listitem>
      <para>Java: <ulink
        url="&url-ddbec-java;blob/master/examples/com/amazonaws/examples/MostRecentEncryptedItem.java"
        >MostRecentEncryptedItem</ulink></para>
    </listitem>
    <listitem>
      <para>Python: <ulink
        url="&url-ddbec-python;blob/master/examples/src/most_recent_provider_encrypted_table.py"
        >most_recent_provider_encrypted_table</ulink></para>
    </listitem>
  </itemizedlist>

  <para role="topiclist"><!-- TOPICLIST --></para>
  <section id="mrp-how-to-use-it">
    <info>
      <title id="mrp-how-to-use-it.title">How to use it</title>
    </info>
    <para>To create a &MRP;, you need to create and configure a provider store, and then create a
      &MRP; that uses the provider store. </para>
    <para>The following examples show how to create a &MRP; that uses a MetaStore and protects the
      versions in its internal &DDB; table with cryptographic materials from a <link
        linkend="direct-kms-provider">&direct-kms;</link>. These examples use the <link
        linkend="mrp-versions"><code>CachingMostRecentProvider</code></link> symbol. </para>
    <para>Each &MRP; has a name that identifies its CMPs in the MetaStore table, a <link
        linkend="most-recent-provider-ttl">time-to-live</link> (TTL) setting, and a cache size
      setting that determines how many entries the cache can hold. These examples set the cache size
      to 1000 entries and a TTL of 60 seconds.</para>
    <tablist>
      <tablistentry>
        <tabname>Java</tabname>
        <tabcontent>
          <programlisting language="java">// Set the name for MetaStore's internal table
final String keyTableName = 'metaStoreTable'

// Set the Region and &CMK; for &KMS;
final String region = 'us-west-2'
final String cmkArn = '&example-key-arn-1;'

// Set the TTL and cache size
final long ttlInMillis = 60000;
final long cacheSize = 1000;

// Name that identifies the MetaStore's CMPs in the provider store
final String materialName = 'testMRP'

// Create an internal DynamoDB client for the MetaStore
final AmazonDynamoDB ddb = AmazonDynamoDBClientBuilder.standard().withRegion(region).build();

// Create an internal &direct-kms; for the MetaStore
final AWSKMS kms = AWSKMSClientBuilder.standard().withRegion(region).build();
final DirectKmsMaterialProvider kmsProv = new DirectKmsMaterialProvider(kms, cmkArn);

// Create an item encryptor for the MetaStore,
// including the &direct-kms;
final DynamoDBEncryptor keyEncryptor = DynamoDBEncryptor.getInstance(kmsProv);

// Create the MetaStore
final MetaStore metaStore = new MetaStore(ddb, keyTableName, keyEncryptor);

//Create the &MRP;
final CachingMostRecentProvider cmp = new CachingMostRecentProvider(metaStore, materialName, ttlInMillis, cacheSize);
</programlisting>
        </tabcontent>
      </tablistentry>
      <tablistentry>
        <tabname>Python</tabname>
        <tabcontent>
          <programlisting language="python"># Designate an &KMS; &CMKlong;
aws_cmk_id = '&example-key-arn-1;'

# Set the name for MetaStore's internal table
meta_table_name = 'metaStoreTable'

# Name that identifies the MetaStore's CMPs in the provider store
material_name = 'testMRP'

# Create an internal DynamoDB table resource for the MetaStore
meta_table = boto3.resource('dynamodb').Table(meta_table_name)

# Create an internal &direct-kms; for the MetaStore
aws_kms_cmp = AwsKmsCryptographicMaterialsProvider(key_id=aws_cmk_id)
    
# Create the MetaStore with the &direct-kms;
meta_store = MetaStore(
    table=meta_table,
    materials_provider=aws_kms_cmp
)

# Create a &MRP; using the MetaStore
#    Sets the TTL (in seconds) and cache size (# entries)
most_recent_cmp = MostRecentProvider(
    provider_store=meta_store,
    material_name=material_name,
    version_ttl=60.0,
    cache_size=1000
)</programlisting>
        </tabcontent>
      </tablistentry>
    </tablist>
  </section>
  <section id="mrp-how-it-works">
    <info>
      <title id="mrp-how-it-works.title">How it works</title>
    </info>
    <para>The &MRP; gets CMPs from a provider store. Then, it uses the CMP to
      generate the cryptographic materials that it returns to the item encryptor.</para>


    <section id="about-mrp">
      <info>
        <title id="about-mrp.title">About the &MRP;</title>
      </info>
      <para>The &MRP; gets a <link linkend="concept-material-provider">cryptographic
        materials provider</link> (CMP) from a <link linkend="provider-store">provider store</link>.
        Then, it uses the CMP to generate the cryptographic materials it returns. Each Most Recent
        Provider is associated with one provider store, but a provider store can supply CMPs to
        multiple providers across multiple hosts.</para>
      <para>The &MRP; can work with any compatible CMP from any provider store. It requests
        encryption or decryption materials from the CMP and returns the output to the item
        encryptor. It does not perform any cryptographic operations.</para>
      <para>To request a CMP from its provider store, the &MRP; supplies its material
        name and the version of an existing CMP it wants to use. For encryption materials, the Most
        Recent Provider always requests the maximum ("most recent") version. For decryption
        materials, it requests the version of the CMP that was used to create the encryption
        materials, as shown in the following diagram.</para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/most-recent-provider-1.png" format="PNG" scale="100"/>
        </imageobject>
        <textobject>
          <phrase>A &MRP;</phrase>
        </textobject>
      </mediaobject>
      <para>The &MRP; saves versions of the CMPs that the provider store returns in a
        local Least Recently Used (LRU) cache in memory. The cache enables the &MRP;
        to get the CMPs that it needs without calling the provider store for every item. You can
        clear the cache on demand.</para>
      <para>The &MRP; uses a configurable <link linkend="most-recent-provider-ttl">time-to-live
          value</link> that you can adjust based on the characteristics of your application.</para>
    </section>

    <section id="about-metastore">
      <info>
        <title id="about-metastore.title">About the MetaStore</title>
      </info>
      <para>You can use a &MRP; with any provider store, including a compatible
        custom provider store. The &DDBEC; includes a MetaStore, a secure implementation that you
        can configure and customize.</para>
      <para>A <emphasis role="italic">MetaStore</emphasis> is a <link linkend="provider-store"
          >provider store</link> that creates and returns <link linkend="wrapped-provider">Wrapped
          CMPs</link> that are configured with the wrapping key, unwrapping key, and signing key
        that Wrapped CMPs require. A MetaStore is a secure option for a &MRP; because Wrapped CMPs
        always generate unique item encryption keys for every item. Only the wrapping key that
        protects the item encryption key and the signing keys are reused.</para>
      <para>The following diagram shows the components of the MetaStore and how it interacts with
        the &MRP;.</para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/most-recent-provider-2.png" format="PNG" scale="85"/>
        </imageobject>
        <textobject>
          <phrase>A MetaStore</phrase>
        </textobject>
      </mediaobject>
      <para>The MetaStore generates the Wrapped CMPs, and then stores them (in encrypted form) in an
        internal &DDB; table. The partition key is the name of the &MRP; material; the sort key its
        version number. The materials in the table are protected by an internal &DDBEC;, including
        an item encryptor and internal <link linkend="concept-material-provider">cryptographic
          materials provider</link> (CMP).</para>
      <para>You can use any type of internal CMP in your MetaStore, including the a <link
        linkend="wrapped-provider">&direct-kms;</link>, a Wrapped CMP with cryptographic
        materials that you provide, or a compatible custom CMP. If the internal CMP in your
        MetaStore is a &direct-kms;, your reusable wrapping and signing keys are protected
        under your <ulink url="&url-kms-dev;">&KMSlong;</ulink> (&KMS;) <ulink
        url="&url-kms-dev;concepts.html#master_keys">&CMKlong;</ulink>. The MetaStore
        calls &KMS; every time it adds a new CMP version to its internal table or gets a CMP version
        from its internal table.</para>
    </section>

    <section id="most-recent-provider-ttl"><info><title id="most-recent-provider-ttl.title">Setting a time-to-live value</title></info>
      <para>You can set a time-to-live (TTL) value for each Most Recent Provider that you create. In
        general, use the lowest TTL value that is practical for your application.</para>
      <para>The use of the TTL value is changed in the <code>CachingMostRecentProvider</code> symbol
        for the &MRP;. </para>
      <note>
        <para>The <code>MostRecentProvider</code> symbol for the &MRP; is deprecated in older
          supported versions of the &DDBEC; and removed from version &mrp-update-version;. It is
          replaced by the <code>CachingMostRecentProvider</code> symbol. We recommend that you
          update your code as soon as possible. For details, see <xref linkend="mrp-versions"
            endterm="mrp-versions.title"/>.</para> </note>   
      <variablelist role="termdef">
        <varlistentry>
          <term><code>CachingMostRecentProvider</code></term>
          <listitem>
            <para>The <code>CachingMostRecentProvider</code> uses the TTL value in two different
              ways. </para>
            <itemizedlist>
              <listitem><para>The TTL determines how often the &MRP; checks the provider store for a new version of the CMP.
                  If a new version is available, the &MRP; replaces its CMP and refreshes its
                  cryptographic materials. Otherwise, it continues to use its current CMP and
                  cryptographic materials.</para></listitem>
              <listitem><para>The TTL determines how long CMPs in the cache can be used. Before it uses a cached CMP for
                  encryption, the &MRP; evaluates its time in the cache. If the CMP cache time
                  exceeds the TTL, the CMP is evicted from the cache and the &MRP; gets a new,
                  latest-version CMP from its provider store.</para></listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><code>MostRecentProvider</code></term>
          <listitem>
            <para>In the <code>MostRecentProvider</code>, the TTL determines how often the &MRP;
              checks the provider store for a new version of the CMP. If a new version is available,
              the &MRP; replaces its CMP and refreshes its cryptographic materials. Otherwise, it
              continues to use its current CMP and cryptographic materials.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>The TTL does not determine how often a new CMP version is created. You create new CMP
        versions by <link linkend="most-recent-provider-rotate">rotating the cryptographic
          materials</link>.</para>

    <para>An ideal TTL value varies with the application and its latency and availability goals. A
        lower TTL improves your security profile by reducing the time that cryptographic materials
        are stored in memory. Also, a lower TTL refreshes critical information more frequently. For
        example, if your internal CMP is a <link linkend="direct-kms-provider">Direct KMS
          Provider</link>, it verifies more frequently that the caller is still authorized to use an
        &KMS; customer master key. </para>
      <para>However, if the TTL is too brief, the frequent calls to the provider store can increase
        your costs and cause your provider store to throttle requests from your application and
        other applications that share your service account. You might also benefit from coordinating
        the TTL with the rate at which you rotate cryptographic materials. </para>
      <para>During testing, vary the TTL and cache size under different work loads until you find a
        configuration that works for your application and your security and performance
        standards.</para>
    </section>
    
    <section id="most-recent-provider-rotate">
      <info>
        <title id="most-recent-provider-rotate.title">Rotating cryptographic materials</title>
      </info>
      <para>When a &MRP; needs encryption materials, it always uses the most recent version of its
        CMP that it knows about. The frequency that it checks for a newer version is determined by
        the <link linkend="most-recent-provider-ttl">time-to-live</link> (TTL) value that you set
        when you configure the &MRP;. </para>
      <para>When the TTL expires, the &MRP; checks the provider store for newer version of the CMP.
        If one is available, the &MRP; get it and replaces the CMP in its cache. It uses this CMP
        and its cryptographic materials until it discovers that provider store has a newer
        version.</para>
        <para>To tell the provider store to create a new version of a CMP for a &MRP;,
        call the provider store's Create New Provider operation with the material name of the 
        &MRP;. The provider store creates a new CMP and saves an encrypted copy in its
        internal storage with a greater version number. (It also returns a CMP, but you can discard
        it.) As a result, the next time the &MRP; queries the provider store for the
        maximum version number of its CMPs, it gets the new greater version number, and uses it in
        subsequent requests to the store to see if a new version of the CMP has been created.</para>
      <para>You can schedule your Create New Provider calls based on time, the number of items or
        attributes processed, or any other metric that makes sense for your application.</para>
    </section>

    <section id="most-recent-provider-encrypt">
      <info>
        <title id="most-recent-provider-encrypt.title">Get encryption materials</title>
      </info>
      <para>The &MRP; uses the following process, shown in this diagram, to get the
        encryption materials that it returns to the item encryptor. The output depends on the type
        of CMP that the provider store returns. The &MRP; can use any compatible
        provider store, including the MetaStore that is included in the &DDBEC;.</para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/most-recent-provider-provider-store.png" format="PNG"
            scale="85"/>
        </imageobject>
        <textobject>
          <phrase>Input, processing, and output of the &MRP; in the &DDBEC;</phrase>
        </textobject>
      </mediaobject>
      <para>When you create a &MRP; by using the <link linkend="mrp-versions"
            ><code>CachingMostRecentProvider</code> symbol</link>, you specify a provider store, a
        name for the &MRP;, and a <link linkend="most-recent-provider-ttl">time-to-live</link> (TTL)
        value. You can also optionally specify a cache size, which determines the maximum number of
        cryptographic materials that can exist in the cache.</para>      
      <para>When the item encryptor asks the &MRP; for encryption materials, the Most
        Recent Provider begins by searching its cache for the latest version of its CMP.</para>
      <itemizedlist>
        <listitem>
          <para>If it finds the latest version CMP in its cache and the CMP has not exceeded the TTL
            value, the &MRP; uses the CMP to generate encryption materials. Then, it returns the
            encryption materials to the item encryptor. This operation does not require a call to
            the provider store.</para>
        </listitem>
        <listitem>
          <para>If the latest version of the CMP is not in its cache, or if it is in the cache but
            has exceeded its TTL value, the &MRP; requests a CMP from its provider store. The
            request includes the &MRP; material name and the maximum version number that it
            knows.</para>
          <orderedlist>
            <listitem>
              <para>The provider store returns a CMP from its persistent storage. If the provider
                store is a MetaStore, it gets an encrypted Wrapped CMP from its internal &DDB; table
                by using the &MRP; material name as the partition key and the version
                number as the sort key. The MetaStore uses its internal item encryptor and internal
                CMP to decrypt the Wrapped CMP. Then, it returns the plaintext CMP to the Most
                Recent Provider . If the internal CMP is a <link linkend="direct-kms-provider"
                >&direct-kms;</link>, this step includes a call to the <ulink
                url="&url-kms-dev;">&KMSlong;</ulink> (&KMS;).</para>
            </listitem>
            <listitem>
              <para>The CMP adds the <code>amzn-ddb-meta-id</code> field to the <link
                linkend="material-description">actual material description</link>. Its value is the
                material name and version of the CMP in its internal table. The provider store
                returns the CMP to the &MRP;.</para>
            </listitem>
            <listitem>
              <para>The &MRP; caches the CMP in memory.</para>
            </listitem>
            <listitem>
              <para>The &MRP; uses the CMP to generate encryption materials. Then, it
                returns the encryption materials to the item encryptor.</para>
            </listitem>
          </orderedlist>
        </listitem>
      </itemizedlist>
    </section>


    <section id="most-recent-provider-decrypt">
      <info>
        <title id="most-recent-provider-decrypt.title">Get decryption materials</title>
      </info>
      <para>When the item encryptor asks the &MRP; for decryption materials, the Most
        Recent Provider uses the following process to get and return them.</para>
      <orderedlist>
        <listitem>
          <para>The &MRP; asks the provider store for the version number of the
            cryptographic materials that were used to encrypt the item. It passes in the actual
            material description from the <link linkend="material-description">material description
            attribute</link> of the item.</para>
        </listitem>
        <listitem>
          <para>The provider store gets the encrypting CMP version number from the
            <code>amzn-ddb-meta-id</code> field in the actual material description and returns it to
            the &MRP;.</para>
        </listitem>
        <listitem>
          <para>The &MRP; searches its cache for the version of CMP that was used to
            encrypt and sign the item.</para>
        </listitem>
      </orderedlist>
      <itemizedlist>
        <listitem>
          <para>If it finds the matching version of the CMP is in its cache and the CMP has not
            exceeded the <link linkend="most-recent-provider-ttl">time-to-live (TTL) value</link>,
            the &MRP; uses the CMP to generate decryption materials. Then, it returns the decryption
            materials to the item encryptor. This operation does not require a call to the provider
            store or any other CMP.</para>
        </listitem>
        <listitem>
          <para>If the matching version of the CMP is not in its cache, or if the cached CMK has
            exceeded its TTL value, the &MRP; requests a CMP from its provider store. It sends its
            material name and the encrypting CMP version number in the request.</para>
          <orderedlist>
            <listitem>
              <para>The provider store searches its persistent storage for the CMP by using the Most
                Recent Provider name as the partition key and the version number as the sort
                key.</para>
              <itemizedlist>
                <listitem>
                  <para>If the name and version number are not in its persistent storage, the
                    provider store throws an exception. If the provider store was used to generate
                    the CMP, the CMP should be stored in its persistent storage, unless it was
                    intentionally deleted.</para>
                </listitem>
                <listitem>
                  <para>If the CMP with the matching name and version number are in the provider
                    store's persistent storage, the provider store returns the specified CMP to the
                    &MRP;. </para>
                  <para>If the provider store is a MetaStore, it gets the encrypted CMP from its
                    &DDB; table. Then, it uses cryptographic materials from its internal CMP to
                    decrypt the encrypted CMP before it returns the CMP to &MRP;. If
                    the internal CMP is a <link linkend="direct-kms-provider">Direct KMS
                    Provider</link>, this step includes a call to the <ulink url="&url-kms-dev;"
                    >&KMSlong;</ulink> (&KMS;).</para>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para>The &MRP; caches the CMP in memory.</para>
            </listitem>
            <listitem>
              <para>The &MRP; uses the CMP to generate decryption materials. Then, it
                returns the decryption materials to the item encryptor.</para>
            </listitem>
          </orderedlist>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section id="mrp-versions">
    <info>
      <title id="mrp-versions.title">Updates to the Most Recent Provider</title>
    </info>    
    <para>The symbol for the Most Recent Provider is changed from <code>MostRecentProvider</code> to
        <code>CachingMostRecentProvider</code>. </para>
    <note>
      <para>The <code>MostRecentProvider</code> symbol, which represents the &MRP;, is deprecated in
        version 1.15 of the &DDBEC; for Java and version 1.3 of the &DDBEC; for Python and removed
        from versions 2.0.0 of the &DDBEC; in both language implementations. Instead, use the
          <code>CachingMostRecentProvider</code>.</para>
    </note>
    <para>The <code>CachingMostRecentProvider</code> implements the following changes:</para>
    <itemizedlist>
      <listitem>
        <para>The <code>CachingMostRecentProvider</code> periodically removes cryptographic
          materials from memory when their time in memory exceeds the configured <link
            linkend="most-recent-provider-ttl">time-to-live (TTL) value</link>. </para>
        <para>The <code>MostRecentProvider</code> might store cryptographic materials in memory for
          the lifetime of the process. As a result, the &MRP; might not be aware of authorization
          changes. It might use encryption keys after the caller's permissions to use them are
          revoked. </para>
        <para>If you can't update to this new version, you can get a similar effect by periodically
          calling the <code>clear()</code> method on the cache. This method manually flushes the
          cache contents and requires the &MRP; to request a new CMP and new cryptographic
          materials. </para>
      </listitem>
      <listitem>
        <para>The <code>CachingMostRecentProvider</code> also includes a cache size setting that
          gives you more control over the cache.</para>
      </listitem>
    </itemizedlist>
    <para>To update to the <code>CachingMostRecentProvider</code>, you have to change the symbol
      name in your code. In all other respects, the <code>CachingMostRecentProvider</code> is fully
      backwards compatible with the <code>MostRecentProvider</code>. You don't need to re-encrypt
      any table items.</para>
    <para>However, the <code>CachingMostRecentProvider</code> generates more calls to the underlying
      key infrastructure. It calls the provider store at least once in each time-to-live (TTL)
      interval. Applications with numerous active CMPs (due to frequent rotation) or applications
      with large fleets are most likely to be sensitive to this change. </para>
    <para>Before releasing your updated code, test it thoroughly to ensure that the more frequent
      calls don't impair your application or cause throttling by services on which your provider
      depends, such as &KMSlong; (&KMS;) or &DDBlong;. To mitigate any performance problems, adjust
      the cache size and the time-to-live of the <code>CachingMostRecentProvider</code> based on the
      performance characteristics you observe. For guidance, see <xref
        linkend="most-recent-provider-ttl" endterm="most-recent-provider-ttl.title"/>.</para>
  </section>
</section>
